# 可中断和不可中断的进程睡眠状态

首先，之前提到了 SIGKILL 和 SIGSTOP 是不可以被阻塞的，即不可以修改这两种信号的默认处理方式（SIGKILL 是终止进程，SIGSTOP 是停止进程）。这个设计意味着总是可以用这些信号杀死或停止一个失控进程。

LINUX中的睡眠状态分为两种。

- TASK_INTERRUPTIBLE：进程正在等待某一事件，例如，终端的输入，等待数据写入当前的空管道。进程在该状态下花费的时间可长可短。如果给这种状态下的进程发送一个信号，那么该进程会被唤醒。
- TASK_UNINTERRUPYIBLE：进程正在等待某些特定类型的事件，比如磁盘I/O的完成。如果这种状态下的进程收到一个信号，那么在摆脱这种状态之前，系统将不会把信号传递给进程。

第二种状态对应的特定类型的事件通常到来的很快，即磁盘I/O瞬间完成，那么进程就很快可以恢复正常。但如果出现某些硬件故障、NFS问题或者内核缺陷而在这种状态下进程保持着不可中断睡眠。这时 SIGKILL 将不会终止挂起进程。如果问题诱因无法解决，那么只能通过重启系统来消灭进程。

从内核 2.6.25开始，Linux加入第三种状态来解决上述进程挂起问题。

- TASK_KILLABLE：该状态类似于 TASK_UNINTERRUPTIBLE ，但是会在进程收到一个致命信号（即一个杀死进程的信号）时将其唤醒。

# 信号传递的时机与顺序

## 何时对一个信号进行递达

使用 raise() 和 kill() 等对进程自身发送信号，信号会立刻被递达。

而收到其他进程或内核发送来的信号，而该信号也未被阻塞，但该信号的产生和递达之间仍有可能存在一个（瞬时）延迟。在此期间，程序处于pending状态。这是因为内核将pending信号传递给进程的时机是，该进程正在执行，且发生了由内核态到用户态的切换。实际上，这意味这以下时刻才会递达信号：

- 进程再次获得CPU调度时（即，在一个时间片的开始处）
- 系统调用完成时（即，内核从核心态返回用户态之前）

## 解除对多个信号的阻塞时，信号的传递顺序

如果进程使用 sigprocmask() 解除了对多个pending信号的阻塞，那么所有这些信号会立即被递达给这个进程。

就目前的Linux 实现来说，Linux内核按照信号编号的升序来传递信号。例如，如果对处于pending的阻塞信号 SIGINT(2) 和 SIGQUIT(3) 同时解除阻塞，那么无论两个信号产生的顺序如何，SIGINT 都将先于 SIGQUIT 而传递。

当多个解除了阻塞的信号正在等待递达的时候，如果在信号处理器函数执行期间发生了内核态到用户态的切换（如信号处理器内部发起了系统调用），那么将中断此信号处理器函数的执行，转而去调用第二个信号处理器函数（如此递进）。

![1558492274854](C:\Users\a1599\AppData\Roaming\Typora\typora-user-images\1558492274854.png)

