# ANSI C、POSIX以及glibc

## ANSI C

ANSI C是美国国家标准委员会（ANSI）定义的C语言标准，C标准库或者libc是ANSI C标准中库函数相关部分。C标准库中提供了许多有用的宏定义、类型定义以及一组最常用的库函数，其中包括字符串处理、数学计算、I/O处理、内存管理以及其它很多操作系统相关的服务。

## POSIX

POSIX标准相对于ANSI C增加了很多非标准的、特定服务于UNIX的功能型库函数，例如多线程、网络以及正则表达式等

## glibc

GNU C库（glibc）是GNU项目对于C标准库的实现，经过多年的发展，glibc现在已经实现了C标准库函数、POSIX库函数以及其它很多有用的库函数

# 系统调用

## 特权

大部分现代处理器结构都包含有一种**安全模型**（security model）。例如，一个应用程序通常被限制在它自己的地址空间中，这样就使得它不能修改其他正在运行的程序甚至是修改操作系统自身，而且普通应用程序通常被限制不能直接操控硬件资源。

然而现实中其实有很多程序都非常需要去得到这些硬件资源（例如几乎所有程序都需要和键盘鼠标显示器交换数据），所以操作系统提供了**系统调用**（system call）来解决这个问题，系统调用被定义来有效的、安全的执行这些与内核资源或硬件资源相关的操作。操作系统工作在最高优先级（可以支配计算机的任何软硬件资源），而它允许用户程序通过系统调用来请求各种服务，系统调用通常通过**中断**（interrupts）来初始化。如果内核同意提供该服务，它会执行一系列不受调用程序控制的机器指令（系统调用），完成后将控制权再交回用户程序。

## 作为中间人的库函数

通常来讲，系统提供了在普通程序和操作系统之间的库函数或者API。在类UNIX系统中，这种API通常是由C库函数（例如glibc）实现的，glibc提供了针对系统调用的外壳函数（wrapper functions），如下图

![1558001266983](C:\Users\a1599\AppData\Roaming\Typora\typora-user-images\1558001266983.png)

这种外壳函数对外暴露正常的程序接口，例如图中execve函数的用法，只需传3个参数path、argv和envp。而外壳函数execve再通过中断等更底层的行为调用内核中的系统调用sys_execve() ，这就使得系统调用使用起来更加的方便。在这种作为中间人的壳函数中，一般会把函数的全部参数放在合适的寄存器中以便传给系统调用，并且把要调用的系统调用的编号放到一个特殊的寄存器中，以便CPU收到中断后知道要执行哪个系统调用。

## 一个具体的例子

**系统调用是受控的内核入口**，借助这一机制，进程可以请求内核以自己的名义去执行某些动作。以应用程序编程接口（API）的形式，内核提供有一系列服务供程序访问。这包括创建新进程、执行I/O，以及为进程间通信创建管道等。

系统调用有以下几个特点：

- 系统调用将处理器从用户态切换到核心态，以便CPU访问受到保护的内核内存。
- 系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识。（程序通过函数名称标识系统调用，对这一编号方案往往一无所知）
- 每个系统调用可辅之以一套参数，对用户空间对内核空间的传参更加规范。

下面以一个具体的硬件平台——x86-32为例，按事件发生的顺序对系统调用的过程加以分析，同样使用上面的图

![1558001266983](C:\Users\a1599\AppData\Roaming\Typora\typora-user-images\1558001266983.png)

1. 应用程序通过调用C语言函数库中的外壳（wrapper）函数，来发起系统调用。
2. 对系统调用中断处理例程来说，外壳函数必须保证所有的系统调用参数可用。通过堆栈，用户提供的参数传入外壳函数，而系统调用一般希望参数在某些合适的寄存器中，于是外壳函数在调用系统调用之前会把参数放到正确的寄存器里。
3. 由于所有的系统调用进入内核的方式相同，内核需要设法区分每个系统调用。为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器（%eax）中。
4. 外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到核心态，并执行系统中断0x80的中断矢量所指向的代码。
5. 为响应0x80中断，内核会调用system_call()例程来处理这次中断，具体如下：a) 在内核栈中保存寄存器值 b) 审核系统调用编号的有效性。 c) 以系统调用编号对存放所有调用服务例程的列表（内核变量sys_call_table）进行索引，发现并调用相应的系统调用服务例程。若系统调用服务例程带有参数，那么将首先检查参数的有效性。随后，该服务例程会执行必要的任务，例如在用户内存和内核内存间传递数据（I/O操作）。最后，该服务例程会将结果状态返回给system_call() 例程。 d) 将系统调用返回值返回至外壳函数，并将处理器切换回用户态。
6. 若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量errno。然后，外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功。（在Linux上，系统调用服务例程遵循的惯例是调用成功返回非负值。发生错误时会对相应的errno常量取反，返回一负值，即每个具体的系统调用错误都被表示成一个正整数常量，定义在errno.h里，出错则返回该常量取反。外壳函数收到系统调用的负返回值就知道系统调用出错，则把errno置为该负值取反（负负得正），并给调用函数返回-1，向调用函数表示有错误发生）

# 总结

因此，从C语言编程的角度来看，调用C语言函数库的外壳（wrapper）函数等同于调用相应的系统调用。

# 参考资料

1. <https://en.wikipedia.org/wiki/System_call>
2. man 2 syscalls